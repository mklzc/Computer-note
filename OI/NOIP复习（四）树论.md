# NOIP复习（四）树论

## 树上倍增

树上倍增其实可以类比为树上二分，不断的去逼近答案。也没有什么好说的直接看题吧。

例 $1.1$：[Tree - 洛谷](https://www.luogu.com.cn/problem/CF932D)

## 最近公共祖先 LCA

求法大致有三种：倍增 $lca$，$Tarjan~lca$（离线），树剖 $lca$ 。

这里用的是树剖 $lca$ （好写好调，常数还小）。

一些概念：

- 重儿子：节点 $x$ 的儿子中子树最大的。

- 重边：节点 $x$ 连向其重儿子的边。

- 重链：重边构成的链。

过程：如果两点在同一条链上，返回深度较小的点。若两点不在同一条链上，找到**所在重链上端点深度较大的节点**更新为其所在重链端点的父节点，直到两点到达同一条链上。

[评测记录 - 洛谷](https://www.luogu.com.cn/record/86056739)

## Kruskal 重构树

我的重构树学习博客：

[简单树论 - qAlex_Weiq - 博客园](https://www.cnblogs.com/alex-wei/p/Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree.html)

[【洛谷日报#68】克鲁斯卡尔重构树略解](https://zhuanlan.zhihu.com/p/47242175)

**一些约定**：

1. 记点 $u,v$ 之间的边权为 $w(u,v)$

2. 在无歧义的情况下，点 $x$ 的点权记为 $w_x$

3. 元素 $x$ 所在集合的代表元素记为：$rep(x)$

回忆 $Kruskal$ 算法求最小生成树的过程：按照边权排序，顺次连接边，并查集判环。

$Kruskal$ 重构树的**建树**：

1. 在每次连边的时候，新建一个节点 $x$，将 $w(u,v)$ 作为 $x$ 的点权。

2. 取消 $u,v$ 之间的连边，将 $rep(u),x$ 和 $rep(v),x$ 之间连接一条有向边。

3. 更新 $rep(u)=rep(v)=x$。

重复以上过程直到选出的边构成原图的一个生成树。

```cpp
int get(int x) { return fa[x] != x ? (fa[x] = get(fa[x])) : x; }
void build(int u, int v, int val)
{
    int pu = get(u), pv = get(v);
    if (pu == pv) return;
    idx++;
    fa[u] = fa[v] = fa[idx] = idx;
    w[idx] = val;
}
```

一些性质：

1. $Kruskal$ 重构树是一个二叉堆（显然加入的节点权值具有单调性）。

2. 原图上的所有节点是重构树的叶子。（考虑重构树的建树过程不难发现）

### Kruskal 重构树的应用

1. **两点之间的最短路上的最大边权**。

给定两点，它们之间的最短路径上的最大值为它们在重构树上 $LCA$ 的点权。

证明：考虑建树的过程，最后加的有关 $(u,v)$ 边一定是最短路径上的最大值，也是 $u,v$ 的 $lca$ 节点。

2. **$Kruskal$ 重构树与倍增**

考虑这样一个问题：从原图的节点 $u$ 出发，经过边权不大于 $d$ 的边，能够到达的所有点。

由于重构树满足二叉堆的性质，那么可以用倍增求出深度最浅的 $w(x)\le d$ 节点 $x$，那么 $x$ 的子树内的所有叶子结点，就是原图上节点 $u$ 能到达的所有点。

需要注意的一点是，在建树过程中，排序既可以从大到小排序，也可以从小到达排序，这也相应的影响了重构树的一些性质。

例 $3.1$：[[NOI2018] 归程 - 洛谷](https://www.luogu.com.cn/problem/P4768)

根据海拔建立 $Kruskal$ 重构树（小根堆），每次询问找到节点 $x$ 满足在 $x$ 的子树中每个点互相可达。

由于车不会再被使用，于是倍增求出深度最浅的满足 $w(x)<p$ 的节点，$x$ 的子树的叶子结点，就是所有可达节点。

想到这里，不难想到 $Dijkstra$ 预处理最短路，树形 $DP$ 搞出以 $x$ 为根的子树中到达节点 $1$ 的最短路径。

这样就可以做到 $O(n\log n)$ 的复杂度。

[评测记录 - 洛谷](https://www.luogu.com.cn/record/86113874)
