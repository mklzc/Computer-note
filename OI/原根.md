# 原根

## 阶

若对于 $p\in \mathbb{N}^{+}, p\neq 1, a\in \mathbb{Z}，$ 满足 $\gcd(a, n) = 1$，则必定 $\exists~r\in \mathbb{N}^{+}, \text{ s.t. } a^r\equiv 1\pmod p$

满足 $a^r\equiv 1\pmod p$ 的最小 $r$ 称为 $a$ 模 $r$ 的阶，记为 $\mathrm{ord}_p(a)=1$

**定理 $1.1：$** 若 $\mathrm{ord}_{p}(a)=r$ ，则对于 $\forall b\in \mathrm{N}^{+}$ 满足 $a^q\equiv 1\pmod n$，都有 $r\mid q$ 。

证明：
反证法，若 $r\nmid q$ ，设 $q=kr+b$（$0<b<r$），则 $a^q\equiv a^{kr+b}\equiv a^{kr}\times a^b\pmod p$

由于 $a^{kr}\equiv a^r\equiv 1\pmod p$ ，可推知 $a^b\equiv 1\pmod p$。

因为 $b < r$ ，这便与阶的定义矛盾。

故命题得证。

特别地，

- 由欧拉定理知，$r\mid \varphi(n)$
- 当 $p$  为素数时，由费马小定理知：$r\mid n-1$

## 原根

定义：设 $p$ 是正整数，$a$ 是整数，若 $a$ 模 $p$ 的阶等于 $\varphi(p)$，则称 $a$ 为模 $p$ 的一个原根。

模板题 : [【模板】原根 - 洛谷](https://www.luogu.com.cn/problem/P6091)

以下结论不做详细证明，记忆即可。

**定理 $2.1$：** 形如 $2,4,2p^c,p^c$ 的数才有原根，其中 $p$ 为奇素数。

**定理 $2.2$：**

当求出一个原根 $g$ 时，可以按照如下方法构造出其他所有原根：所有的 $g^k, k\perp \varphi(p)$ 。

$(g^k)^{\varphi(p)}\equiv 1\pmod p$

若存在 $(g^k)^x\equiv 1\pmod p, x < \varphi(p)$

那么必然存在 $g^{kx\bmod \varphi(p)}\equiv 1$，与 $g$ 是原根矛盾。

**定理 $2.3$：**

判断 $a$ 在 $\bmod p$ 意义下的阶是否为 $\varphi(p)$ 时，只需要求得 $\varphi(p)$ 的质因数 $p_1,p_2\dots$，然后判断 $a^{\frac{\varphi(p)}{p_i}}$ 即可。

由定理 $1.1$ 可知，判定 $a^x\equiv 1$ 只需判定 $\varphi(p)$ 的所有约数即可。

又 $a^{x}\equiv 1$ 时，必定有 $a^{cx}\equiv 1$ 。

那么，可以证明取出所有 $\varphi(p)/p_i$ 即可判断 $a$ 的阶是否为 $\varphi(p)$ 。

根据如上三个定理，即可通过此题（注意特判模数为 $2$ 的情况）。

```cpp
#define int long long
int T, mod, d;
std::vector<int> seq, ans;
int qpow(int a, int b, int mod)
{
    int res = 1;
    for (; b; b >>= 1){
        if (b & 1) res = 1ll * res * a % mod;
        a = 1ll * a * a % mod;
    }return res;
}
int getphi(int x){
    int res = x;
    for (int i = 2; i * i <= x; i++){
        if (x % i == 0) {
            res = res * (i - 1) / i;
            while (x % i == 0) x /= i;
        }
    }if (x > 1) res = res * (x - 1) / x;
    return res;
}
void getfac(int x) {
    int sav = x;
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            while (x % i == 0) x /= i;
            seq.push_back(sav / i);
        }
    } if (x > 1) seq.push_back(sav / x);
}
int gcd(int x, int y){return y ? gcd(y, x % y) : x;}
bool check(int x)
{
    for (auto y : seq)
        if (qpow(x, y, mod) == 1) return false;
    return gcd(x, mod) == 1;
}
signed main()
{
    read(T);
    while (T--)
    {
        seq.clear(), seq.shrink_to_fit();
        ans.clear(), ans.shrink_to_fit();
        read(mod, d);
        if (mod == 2){
            if (d == 1) puts("1\n1");
            else puts("1\n");continue;
        }
        int phi = getphi(mod), yg = 0;
        getfac(phi);
        rep(i, 1, 200)
            if (check(i)) {yg = i; break;}
        int len = 1;
        if (yg) {
            ans.push_back(-1);
            rep(i, 1, phi - 1)
                if (gcd(i, phi) == 1) ans.push_back(qpow(yg, i, mod));
            std::sort(ans.begin(), ans.end());
            len = ans.size();
        }
        printf("%d\n", len - 1);
        for (int i = d; i < len; i += d)
            printf("%d ", ans[i]);
        puts("");
    }
    return 0;
}
```
