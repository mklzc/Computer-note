# 动态规划 Dynamic Programming

蒟蒻的 `DP` 入门之路。

## 题目

### [Mr's Young's Picture Permutation](https://www.acwing.com/problem/content/273/)

#### 思路

考虑将人按身高降序安排。

状态表示：$f[a_1][a_2][a_3][a_4][a_5]$ 表示第 `i` 排有 $a_i$ 个人。

状态转移：

$if (a_i < a_{i - 1}\ and\ a_i < N_i): $
$\ \ \ f[a_1]\dots f[a_i + 1]\dots f[a_5]+=f[a_1][a_2][a_3][a_4][a_5]$

初始化：
$f[0][0][0][0][0] = 1$

### [LCIS](https://www.acwing.com/problem/content/274/)

思路：

综合 `LCS` 和 `LIS` 可以得出：

状态表示：`f[i][j]` 表示 $A[1 \sim i]$ 和以 $B[j]$ 结尾的 `LCIS`

转移方程：
$if (A[i] = B[j]) f[i][j] = \max_{1\le k\le j - 1,B_k < A_k}{\{f[i - 1][k]\}}$
$if (A[i] \neq B[j]) f[i][j] = f[i - 1][j]$

考虑到每次进行决策时 `i - 1` 始终不改变，造成了很多重复比较。

那么可以维护一个 `val` 当 $f[i][j] \to f[i][j + 1]$ 更新 `val` 的值。

时间复杂度：$O(N^2)$

### [最大食物链计数](https://www.luogu.com.cn/problem/P4017)

`f[x]` 表示以 `x` 结尾的最大食物链条数。

```text
动态规划对状态空间的遍历构成一张有向无环图，遍历顺序就是该有向无环图的一个拓朴序。
```

那么对于这道题而言，食物网构成一张有向无环图，遍历也应该是一个拓朴序。

考虑在拓朴排序时，用当前节点 `x` 更新其子节点 `y`，即 `f[y] += f[x]`。

### [石子合并](https://www.luogu.com.cn/problem/P1880)

区间 $DP$

`f[i][j] = f[i][k] + f[k + 1][j] + sum[i][j]`

枚举时，应枚举 $i-j$，否则无法完成对状态空间的拓扑序遍历。

### [棋盘分割](https://www.luogu.com.cn/problem/P1436)

二维区间 $DP$。

$F(k, i, j, x, y)$ 表示左上角坐标为 $(i, j)$，右下角坐标为 $(x, y)$ 的方阵割了 $k$ 次后的最小平方和。

转移即可。

## [[CSP-S 2021] 括号序列](https://www.luogu.com.cn/problem/P7914)

题意简述：

形如：`(s), (), ASB, AB, (A), (SA), (AS)` 均为合法的超级括号序列。

现给定长度为 $n$ 且某些位置已经确定的括号序列，求满足条件的超级括号序列有多少个。

设超级括号序列有以下 $5$ 种形态：

0. 形如 $**\dots **$（即全部为 $*$）

1. 形如 $(**\dots **)$ （左右两端括号相互匹配）

2. 形如 $(\dots)\dots **$ （左边以括号序列开头，右边以 $*$ 结尾）。

3. 形如 $**\dots (\dots)$ （左边以 $*$ 开头，右边以括号序列结尾）。

4. 形如 $(\dots)\dots(\dots)$ （左边以括号序列开头，右边以括号序列结尾）。

写出转移方程：

$dp(l,r,1)=check(l,r)*(dp(l+1,r-1,0)+dp(l+1,r-1,2)+dp(l+1,r-1,3)+dp(l+1,r-1,4))$

$dp(l,r,2)=\sum_{k=l}^{r-1}{dp(l,k,4)*dp(k+1,r,0)}$

$dp(l,r,3)=\sum_{k=l}^{r-1}{dp(l,k,0)*dp(k+1,r,4)}$

$dp(l,r,4)=\sum_{k=l}^{r-1}({dp(l,k,2)+dp(l,k,4)})*dp(k+1,r,1)+dp(l,r,1)$

[参考题解](https://www.luogu.com.cn/blog/wsyear/solution-p7914) （优化掉了此篇题解中的 $dp(l, r, 5)$）

代码：

```cpp
#include <bits/stdc++.h>
using LL = long long;
const int mod = 1000000007, Maxn = 505;
int n, k;
LL f[Maxn][Maxn][5];
char s[Maxn];
int main()
{
    scanf("%d %d", &n, &k);
    scanf("%s", s + 1);
    auto add = [](LL x, LL y) ->LL{
        return (x + y) % mod;
    };
    for (int i = 1; i <= n; i++) 
    {
        f[i][i - 1][0] = 1;
        f[i][i][0] = (s[i] == '*' || s[i] == '?');
    }
    for (int len = 1; len <= n; len++)
    {
        for (int l = 1; l <= n - len + 1; l++)
        {
            int r = l + len - 1;
            if (len <= k) f[l][r][0] = f[l][r - 1][0] && (s[r] == '*' || s[r] == '?');
            if ((s[l] == '(' || s[l] == '?') && (s[r] == ')' || s[r] == '?'))
                f[l][r][1] = (add(f[l + 1][r - 1][0], f[l + 1][r - 1][2]) + add(f[l + 1][r - 1][3], f[l + 1][r - 1][4])) % mod;
            for (int k = l; k <= r - 1; k++)
            {
                f[l][r][2] = (f[l][r][2] + f[l][k][4] * f[k + 1][r][0]) % mod;
                f[l][r][3] = (f[l][r][3] + f[l][k][0] * f[k + 1][r][4]) % mod;
                f[l][r][4] = (f[l][r][4] + add(f[l][k][4], f[l][k][2]) * f[k + 1][r][1]) % mod;
            }
            f[l][r][4] = add(f[l][r][4], f[l][r][1]);
        }
    }
    printf("%lld\n", f[1][n][4]);
    return 0;
}
```

### [[ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602)

数位 $DP$，往模板上套，$pos$ 记录位置，$lim$ 记录是否卡上界，pre0 判断前导零。

```cpp
#define int long long
#define fi first
#define se second
using LL = long long;
const int Maxn = 15;
LL a, b;
std::pair<LL, LL> f[Maxn];
LL cnta[Maxn], cntb[Maxn], num[Maxn];
// first: 所有符合条件的数 second: 数字出现的个数
std::pair<LL, LL> dp(int pos, bool lim, bool pre0, int x)
{
    if (!pos) return {pre0 ? 0 : 1, 0}; 
    if (!lim && !pre0 && f[pos].fi != -1) return f[pos];
    int up = lim ? num[pos] : 9, res1 = 0, res2 = 0;
    for (int i = 0; i <= up; ++i)
    {
        auto t = dp(pos - 1, lim && i == up, pre0 && !i, x);
        res1 += t.fi;
        res2 += t.se;
        if (!i && pre0) continue;
        if (i == x) res2 += t.fi;
    }
    if (!lim && !pre0) f[pos] = {res1, res2};
    return {res1, res2};
}
void solve(int *cnt, int x)
{
    int dgt = 0;
    while (x)
        num[++dgt] = x % 10, x /= 10;
    for (int i = 0; i <= 9; i++)
    {
        for (int i = 0; i <= 12; i++) f[i] = {-1, -1};
        cnt[i] = dp(dgt, true, true, i).se;
    }
}
signed main()
{
    scanf("%lld %lld", &a, &b);
    solve(cnta, a - 1);
    solve(cntb, b);
    for (int i = 0; i <= 9; i++)
        printf("%lld ", cntb[i] - cnta[i]);
    return 0;
}
```

## [windy 数](https://www.luogu.com.cn/problem/P2657)

数位 DP。

题意简述：求 $[l, r]$ 之间的相邻数字差大于等于 $2$ 的数的个数。

需要判断前导零。

贴上代码：

```cpp
int dfs(int pos, bool limit, bool prez, int lst)
{
    if (!pos) return (prez != true);
    if (!limit && !prez && ~f[pos][lst]) return f[pos][lst];
    int up = limit ? digit[pos] : 9, res = 0;
    for (int i = 0; i <= up; i++)
    {
        if (std::abs(i - lst) < 2) continue;
        // 判断是否有前导零：
        // 如果有前导零，就按照正常的往下搜，将上一个数赋为 -2 即可。
        if (prez && !i) res += dfs(pos - 1, limit && i == up, true, -2);
        // 如果没有前导零，就将上一个赋为 i。
        else res += dfs(pos - 1, limit && i == up, false, i);
    }
    if (!limit && !prez) f[pos][lst] = res;
    return res;
}
```

## [花神的数论题](https://www.luogu.com.cn/problems/P4317)

题意简述：记 $sum(i)$ 表示 $i$ 在二进制下所有位数的和，求 $\prod_{i=1}^{n}{\mathrm{sum(i)}}$ 。

数位 $DP$。

求出在 $[1, n]$ 二进制下和为 $s, (s\in [1, 32])$ 的数的个数。

如此便可以转化为二进制下的数位 $DP$ 。

贴上代码：

```cpp
LL dfs(int pos, bool limit, int sum)
{
    // 递归边界：若 和 为钦定值，返回 1.
    if(!pos) return sum == I;
    if (!limit && ~f[pos][sum]) return f[pos][sum];
    int up = limit ? digit[pos] : 1;
    LL res = 0;
    for (int i = 0; i <= up; i++)
        // 若该位为 1, 和每次 +1
        res += dfs(pos - 1, limit && i == up, sum + (i == 1));
    if (!limit) f[pos][sum] = res;
    return res;
}

LL solve(LL x)
{
    cnt = 0;
    while (x)
        // 二进制下的拆位
        digit[++cnt] = x & 1, x >>= 1;
    LL ans = 1;
    for (int i = 1; i <= Maxn; i++)
    {
        I = i, memset(f, -1, sizeof(f));
        // ans 每次乘以贡献
        ans = (ans * qpow(i, dfs(cnt, true, 0))) % mod;
    }
    return ans;
}
```

## [同类分布](https://www.luogu.com.cn/problems/P)

题意简述：求 $[l, r]$ 之间数字和整除原数的数的个数。

数位 $DP$。

分别计算数字和为 $s$ 时的答案，$DP$ 数组记录三维，分别是位置，当前位数和，模意义下的原数。

```cpp
LL dfs(int pos, int sum, bool limit, int num)
{
    // 递归边界：数在模意义下为 0，且数字和为 mod 时。
    if (!pos) return !num && sum == mod;
    if (!limit && f[pos][sum][num] != -1) return f[pos][sum][num];
    int up = limit ? digit[pos] : 9;
    LL res = 0;
    for (int i = 0; i <= up; i++)
        if (sum + i <= mod)
            res += dfs(pos - 1, sum + i, limit && i == up, (num * 10ll + i) % mod);
    if (!limit) f[pos][sum][num] = res;
    return res;
}
int cnt = 0;
LL calc(LL val)
{
    cnt = 0;
    while (val)
        digit[++cnt] = val % 10, val = val / 10;
    LL ans = 0;
    for (int i = 1; i <= 9 * cnt; i++){
        memset(f, -1, sizeof(f));
        mod = i;
        ans += dfs(cnt, 0, true, 0);
    }
    return ans;
}
```

总结一下：

由以上四道题可以看出：数位 $DP$ 较为套路，有固定的模板，只需要在使用时稍加转化即可。

## [同类分布](https://www.luogu.com.cn/problems/P )

状压 $DP$

比较经典的一道状压 $DP$ 。

三维数组 $f[i][j][k]$ ，分别记录当前是第几行，当前行的状态为 $j$ ，已经填了多少个数。

转移：$f[i][j][k] = f[i - 1][t][l]$

$t$ 是与 $j$ 不冲突的上一行的状态，$l$ 是一个小于 $k$ 的数。

具体地，$l\le k - cnt[i]$ ，其中 $cnt[i]$ 表示 $i$ 状态下填了几个数。

一点点优化：预处理出所有可行的状态在进行转移，时间效率上有所提升。

贴上代码：

```cpp
#include <bits/stdc++.h>
const int Maxn = 12;
using LL = long long;
int n, k, tot, cnt[1 << Maxn], state[1 << Maxn];
LL f[Maxn][1 << Maxn][Maxn * Maxn];

void init()
{
    for (int i = 0; i < (1 << n); i++)
    {
        if (i & (i << 1)) continue;
        int sum = 0;
        for (int j = 0; j < n; j++)
            if ((i >> j) & 1) ++sum;
        state[++tot] = i, cnt[tot] = sum;
    }
}
int main()
{
    scanf("%d %d", &n, &k);
    init(); 
    f[0][0][0] = 1;
    for (int i = 1; i <= n; i++)
        for (int cur = 1; cur <= tot; cur++)
        {
            for (int l = cnt[cur]; l <= k; ++l)
            {
                for (int lst = 1; lst <= tot; lst++)
                {
                    if (state[cur] & state[lst]) continue;
                    if (state[cur] & (state[lst] << 1)) continue;
                    if ((state[cur] << 1) & state[lst]) continue;
                    f[i][state[cur]][l] += f[i - 1][state[lst]][l - cnt[cur]];
                }
            }
        }
    LL ans = 0;
    for (int i = 1; i <= tot; i++)
        ans += f[n][state[i]][k];
    printf("%lld\n", ans);
    return 0;
}
```

## [炮兵阵地](https://www.luogu.com.cn/problem/P2704)

状压 $DP$ ，与上一道题十分相似。

设 $f[i][j][k]$ 表示当前为第 $i$ 行，当前行的状态为 $j$ ，上一行的状态为 $k$ 可以填的最大阵地数。

考虑转移：

$f[i][j][k] = \max\{f[i - 1][k][l]\}$ 其中 $l$ 枚举的是与 $k$ 和 $j$ 不冲突的状态。

但是对于这道题来说有一个问题，空间如果开成 $f[Maxn][1 << Maxm][1 << Maxm]$ 就会 $MLE$ 。

借鉴上道题预处理的思路：

预处理出所有可行的状态，打表输出后发现最多只有 $60$ 个状态满足条件，远远小于 $1 << Maxm$ 。

在实现的时候有一个小技巧：将输入的每一行也压为一个数，这样判断是否冲突时就可以直接或起来了。

具体实现见代码：

```cpp
#include <bits/stdc++.h>
const int Maxn = 102, Maxm = 9, lim = 65;
int n, m, f[Maxn][lim][lim];
int cnt[lim], sta[lim], ban[Maxn], tot;
inline void init()
{
    for (int i = 0; i < (1 << m); i++)
    {
        if (i & (i << 1)) continue;
        if (i & (i << 2)) continue;
        int sav = 0;
        for (int j = 0; j < m; j++)
            if ((i >> j) & 1) sav++;
        cnt[++tot] = sav;
        sta[tot] = i;
    }
}
int main()
{
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            char ch;
            do{
                ch = getchar();
            }while (ch != 'H' && ch != 'P');
            ban[i] = (ban[i] << 1) + (ch == 'H');
        }
    init();
    auto check_dx = [](int raw, int id) {
        return (ban[raw] & sta[id]);
    };
    auto check_pb = [](int x, int y){
        return (sta[x] & sta[y]);
    };
    for (int i = 1; i <= tot; i++)
    {
        if (check_dx(1, i)) continue;
        f[1][i][0] = cnt[i];
    }
    if (n == 1)
    {
        int ans = 0;
        for (int i = 1; i <= tot; i++)
            ans = std::max(ans, cnt[i]);
        return printf("%d", ans), 0;
    }
    for (int i = 1; i <= tot; i++)
    {
        if (check_dx(2, i)) continue;
        for (int j = 1; j <= tot; j++)
        {
            if (check_dx(1, j) || check_pb(i, j)) continue;
            f[2][i][j] = std::max(f[2][i][j], f[1][j][0] + cnt[i]);
        }
    }
    for (int i = 3; i <= n; i++)
    {
        for (int j = 1; j <= tot; j++)
        {
            if (check_dx(i, j)) continue;
            for (int k = 1; k <= tot; k++)
            {
                if (check_pb(k, j) || check_dx(i - 1, k)) continue;
                for (int l = 1; l <= tot; l++)
                {
                    if (check_pb(k, l) || check_pb(j, l) || check_dx(i - 2, l))
                        continue;
                    f[i][j][k] = std::max(f[i][j][k], f[i - 1][k][l] + cnt[j]);
                }
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= tot; i++)
        for (int j = 1; j <= tot; j++)
            ans = std::max(ans, f[n][i][j]);
    printf("%d\n", ans);
    return 0;
}
```

总结一下：

上面两道状压 $DP$ 题较为经典，但是状压的核心思想是不变的：即将比较小的状态压缩为一个十进制数，然后进行转移。

## [[SHOI]百事世界杯之旅](https://www.luogu.com.cn/problem/P1291)

期望 $DP$ ：

引入一下数学期望：

数学期望的本质是足够多次的事件后所产生的均值。

是所有值与概率乘积和。

这道题便是一个比较经典的数位 $DP$ 。

题意简述：

有 $n$ 个数，出现的概率相同，每次选取一个数，求期望在多少次后，每个数都出现了至少一次。

设 $f[i]$ 表示已经抽出了 $i$ 个数，还期望多少次使得所有数出现了至少一次。

考虑转移：$f[i]=\frac{k}{n}f[i]+\frac{n-k}{n}f[i-1]+1$

变换一下得到 $f[i-1]=f[i]+\frac{n}{n-k}$ 。

具体实现时搞一个分数类即可。

```cpp
#include <bits/stdc++.h>
using LL = long long;
int get_digit(LL x)
{
    int cnt = 0;
    while (x) x = x / 10, cnt++;
    return cnt;
}
void out(int cnt, char ch) { while (cnt--) std::cout << ch; }
struct Node
{
    LL de, nu;
    Node(LL _de = 1, LL _nu = 0) {nu = _nu, de = _de;}
    void print()
    {
        LL sav = nu / de;
        if (!nu) return void(puts("0"));
        if (de == 1) return void(std::cout << nu);
        if (!sav)
        {
            int d = get_digit(de);
            std::cout << nu << "\n";
            out(d, '-');
            std::cout << "\n" << nu << "\n";
        }
        else
        {
            LL buf = nu - de * sav, d = get_digit(de);
            int space = get_digit(sav);
            out(space, ' '); std::cout << buf << "\n";
            std::cout << sav; out(d, '-'); std::cout << "\n";
            out(space, ' '); std::cout << de << "\n";
        }
    }
};
Node operator+(const Node &a, const Node &b)
{
    LL newde = a.de * b .de, newnu = a.de * b.nu + a.nu * b.de;
    LL d = std::__gcd(newde, newnu);
    return Node(newde / d, newnu / d);
}
const int Maxn = 50;
int n;
Node f[Maxn];
int main()
{
    scanf("%d", &n);
    for (int i = n - 1; i >= 0; i--)
        f[i] = f[i + 1] + Node(n - i, n);
    f[0].print();
    return 0;
}
```
