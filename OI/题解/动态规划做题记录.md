# 动态规划 Dynamic Programming

蒟蒻的 `DP` 入门之路。

## 题目

### [Mr's Young's Picture Permutation](https://www.acwing.com/problem/content/273/)

#### 思路

考虑将人按身高降序安排。

状态表示：$f[a_1][a_2][a_3][a_4][a_5]$ 表示第 `i` 排有 $a_i$ 个人。

状态转移：

$if (a_i < a_{i - 1}\ and\ a_i < N_i): $
$\ \ \ f[a_1]\dots f[a_i + 1]\dots f[a_5]+=f[a_1][a_2][a_3][a_4][a_5]$

初始化：
$f[0][0][0][0][0] = 1$

### [LCIS](https://www.acwing.com/problem/content/274/)

思路：

综合 `LCS` 和 `LIS` 可以得出：

状态表示：`f[i][j]` 表示 $A[1 \sim i]$ 和以 $B[j]$ 结尾的 `LCIS`

转移方程：
$if (A[i] = B[j]) f[i][j] = \max_{1\le k\le j - 1,B_k < A_k}{\{f[i - 1][k]\}}$
$if (A[i] \neq B[j]) f[i][j] = f[i - 1][j]$

考虑到每次进行决策时 `i - 1` 始终不改变，造成了很多重复比较。

那么可以维护一个 `val` 当 $f[i][j] \to f[i][j + 1]$ 更新 `val` 的值。

时间复杂度：$O(N^2)$

### [最大食物链计数](https://www.luogu.com.cn/problem/P4017)

`f[x]` 表示以 `x` 结尾的最大食物链条数。

```text
动态规划对状态空间的遍历构成一张有向无环图，遍历顺序就是该有向无环图的一个拓朴序。
```

那么对于这道题而言，食物网构成一张有向无环图，遍历也应该是一个拓朴序。

考虑在拓朴排序时，用当前节点 `x` 更新其子节点 `y`，即 `f[y] += f[x]`。

### [石子合并](https://www.luogu.com.cn/problem/P1880)

区间 $DP$

`f[i][j] = f[i][k] + f[k + 1][j] + sum[i][j]`

枚举时，应枚举 $i-j$，否则无法完成对状态空间的拓扑序遍历。

### [棋盘分割](https://www.luogu.com.cn/problem/P1436)

二维区间 $DP$。

$F(k, i, j, x, y)$ 表示左上角坐标为 $(i, j)$，右下角坐标为 $(x, y)$ 的方阵割了 $k$ 次后的最小平方和。

转移即可。

### [[ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602)

数位 $DP$

往模板上套。

```cpp
int f[Maxn];
/*
模板
变量含义：
num: 该数字的每一位
pos: 从高到低第 pos 位。
lim: 是否卡上界
pre0: 是否是前导零
*/
int dfs(int pos, bool lim, bool pre0, int cnt)
{
    if (!pos) return 0;
    if (!lim && !pre0 && f[pos] != -1) return f[pos];
    int res1 = 0, res2 = 0;
    int up = lim ? num[pos] : 9;
    for (int i = 0; i <= 9；i++)
        res += dp(pos - 1, lim && i == up, pre0 && i == 0, cnt);
    if (!pre0 && !lim) f[pos] = res;
    return x;
}
```

```cpp
#include <bits/stdc++.h>
#define int long long
#define fi first
#define se second
using LL = long long;
const int Maxn = 15;
LL a, b;
std::pair<LL, LL> f[Maxn];
LL cnta[Maxn], cntb[Maxn], num[Maxn];
// first: 所有符合条件的数 second: 数字出现的个数
std::pair<LL, LL> dp(int pos, bool lim, bool pre0, int x)
{
    if (!pos) return {pre0 ? 0 : 1, 0}; 
    if (!lim && !pre0 && f[pos].fi != -1) return f[pos];
    int up = lim ? num[pos] : 9, res1 = 0, res2 = 0;
    for (int i = 0; i <= up; ++i)
    {
        auto t = dp(pos - 1, lim && i == up, pre0 && !i, x);
        res1 += t.fi;
        res2 += t.se;
        if (!i && pre0) continue;
        if (i == x) res2 += t.fi;
    }
    if (!lim && !pre0) f[pos] = {res1, res2};
    return {res1, res2};
}
void solve(int *cnt, int x)
{
    int dgt = 0;
    while (x)
        num[++dgt] = x % 10, x /= 10;
    for (int i = 0; i <= 9; i++)
    {
        for (int i = 0; i <= 12; i++) f[i] = {-1, -1};
        cnt[i] = dp(dgt, true, true, i).se;
    }
}
signed main()
{
    scanf("%lld %lld", &a, &b);
    solve(cnta, a - 1);
    solve(cntb, b);
    for (int i = 0; i <= 9; i++)
        printf("%lld ", cntb[i] - cnta[i]);
    return 0;
}
```
